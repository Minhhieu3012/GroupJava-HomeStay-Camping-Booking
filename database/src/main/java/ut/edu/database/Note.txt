- Clean Architecture / layered architecture ( cấu trúc sạch / cấu trúc lớp )
- Request từ client --> Controller --> Service --> Repo --> Entity --> Và ngược lại --> Response

- Flow hoạt động chi tiết:
    1. Khi client gọi API:
        - Step 1: controllers (API layer):
            + Nhận request từ client thông qua @RestController
            + Gọi service tương ứng
            + Trả response cho client (thường là DTO)
        - Step 2: service (Business logic):
            + Chứa toàn bộ logic, xử lí nghiệp vụ
            + Gọi class repo để truy vấn DB
            + Chuyển đổi từ entity --> dto qua mapper
        - Step 3: repo (Data access layer)
            + Sử dụng Spring data jpa để thao tác trực tiếp với DB
            + không cần viết sql - tự sinh method name
        - Step 4: models (Entity classes):
            + Đại diện cho bảng trong csdl (ORM - obj relation mapping)
            + Có annotation như @Entity, @Table, @ManyToOne,...
        - Step 5: mapper (Obj mapping):
            + Dùng để convert từ Entity --> Dto
            + Thường xài @Mapper(componentModel = "Spring") với Mapstruct or dùng tay
        - Step 6: dtos (Data Transfer Object)
            + Chỉ chứa dữ liệu cần thiết để gửi / nhận từ fe
            + không chứa logic hay annotation JPA
        - Step 7:
            + Và sau đó trả ResponseEntity<..DTO> từ controller --> client

- Flow login / register (Auth Flow):
    + Người dùng gọi /api/auth/login hoặc /register
    + AuthController gọi AuthService
    + AuthService xác thực người dùng với UserRepository
    + Nếu đúng → tạo JWT token với JwtService
    + Token được trả lại cho client và kèm theo trong các request tiếp theo ở phần header
    + JwtAuthenticationFilter (tầng bảo mật) sẽ giải mã token và inject UserDetails vào context.

- Config bảo mật & tiện ích khác:
    + SecurityConfig → cấu hình các URL nào cần đăng nhập / vai trò nào mới truy cập được.
    + PasswordEncoderConfig → Bean để mã hóa mật khẩu bằng BCrypt
    + SwaggerConfig → Bật UI cho test API dễ hơn